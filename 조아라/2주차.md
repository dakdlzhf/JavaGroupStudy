



## 타입변환과 다형성

[1] 다형성 : 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질

=> 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해줌

- 자바는 다형성을 위해 **부모클래스로 타입 변환을 허용**함

  => 부모 타입에 모든 자식 객체가 대입될 수 있음

  => 객체의 부품화 가능

[2] 타입 변환 : 데이터 타입을 다른 데이터 타입으로 변환하는 것

- 상속관계에 있는 클래스 사이에서 클래스 타입의 변환 발생
- 자식 타입은 부모 타입으로 자동 타입 변환 가능

```
/* 업캐스팅 & 다운캐스팅 */
Object obj = new String("abc");
String str = obj; ---------------- (O) // obj가 값이므로 가능, 다운캐스팅
String str = new Object(); ------- (X) // 좌우 변경해야함
Object obj = new String(); ------- (O) // 업캐스팅
```

- 자동타입변환(업캐스팅, 묵시적,Promotion) : 프로그램 실행 도중 자동으로 타입변환이 일어나는 것

  ```
  //부모클래스 변수 = 자식타입 객체
  SuperClass super = new SubClass();
  ```

  - 부모의 특징과 기능을 상속받으므로 자식이 부모와 동일하게 취급될 수 있음.

  - 실제 메모리에 생성되는 객체는 부모, 자식 모두. 타입만 부모

  - 서브클래스의 레퍼런스값을 슈퍼클래스 타입의 변수에 대입

  - 작은데이터 타입을 큰 테이터 타입으로

  - 필드 값 대입할때도 발생하지만 주로 메소드 호출 시 많이 발생

  - 부모 타입으로 변환 이후, 부모 클래스에 선언된 멤버(필드와 메소드)만 접근 가능

    (자식 객체 내에 있는 모든 멤버를 접근할 수 없음)

    *예외: 오버라이딩 시 부모클래스 타입이더라도 자식 클래스의 메소드 대신 호출(동적바인딩)

  - 필드의 다형성 : 필드의 타입은 변함 없지만 실행 도중 어떤 객체를 필드로 저장하느냐에 따라 실행 결과가 달라질 수 있음

  - 상속관계에 있는 객체들을 배열로 관리 가능

  - 매개변수의 다형성

  ```
  매개변수의 타입 클래스경우, 해당클래스의 객체뿐만 아니라 자식 객체도 매개 값으로 사용가능
  매개값으로 어떤 자식 객체가 제공되느냐에 따라 메소드의 실행결과는 다양해 질 수 있음
  ```

- 강제타입변환(다운캐스팅, 명시적,Casting) : 강제적으로 개발자가 설정

  ```
  //자식클래스 변수 = (자식타입) 부모타입객체
  SubClass sub = (SubClass) SuperClass();
  ```

  - 슈퍼클래스의 레퍼런스를 서브 클래스 타입의 변수에 대입

  - 업캐스팅 된 것을 다시 원래대로 되돌리는 것

  - 명시적으로 타입 지정

  - 큰 데이터 타입을 작은 데이터 타입으로

  - 상위클래스의 멤버변수 및 메소드에만 접근 가능(사용할 수 있는 멤버변수를 제한)

  - 상위클래스 메소드를 하위클래스에서 재정의한 경우 오버라이딩 메소드가 호출

  - `instanceof` 연산자를 사용하여 강제타입변환이 가능한지 확인

    => 생성된 객체가 클래스와 관계있는 타입으로 만들어졌는지 확인(true/false)

    ```
    boolean result = 좌항(객체) instanceof 우항(타입)
    ```

## 추상클래스

실체클래스들의 공통적 특성을 추출해서 선언한 클래스, 추상메소드를 0개이상 가지고 있는 클래스

(*실체클래스 : 객체를 직접 생성할 수 있는 클래스)

추상클래스(부모)와 실체(자식)클래스는 상속의 관계

추상클래스는 객체를 생성 할 수 없음(new 연산자로 인스턴스 생성 x)

실체클래스는 추상클래스의 모든 특성을 물려받고 추가적인 특성을 가질 수 있음

특성 제한자(abstract, static, final)는 순서가 상관없음.

메소드 선언시 abstract public ~, public abstract ~ 둘다 맞음.

### 용도

[1] 실체클래스의 공통된 필드와 메소드의 이름을 통일할 목적

- 동일한 데이터와 기능을 같은 이름의 메소드로 만들고 사용할 수 있음

[2] 실체클래스를 작성할 때 시간 절약

- 공통된 필드와 메소드는 추상클래스를 상속해 구체적으로 만들어 사용하고 다른점만 실체클래스에 추가로 선언하여 작성시 시간을 절약할 수 있음

### 선언

클래스 선언에 abstract 키워드 붙임.

new연산자로 직접 생성자를 호출할 수는 없지만 자식객체가 생성될때 super(...) 호출하므로 추상클래스도 생성자가 반드시 있어야함

### 추상메소드와 오버라이딩

메소드선언만 통일화 하고 실행내용은 실체클래스마다 달라야하는 경우가 있음

=> 추상메소드를 추상클래스에 선언하고 오버라이딩하여 사용

추상메소드: 메소드의 선언부만 있고 중괄호{}가 없는 메소드, 서브클래스에서 반드시 오버라이딩해서 구현(하지 않으면 서브 클래스의 메소드도 추상메소드가 됌, 컴파일에러발생)

- 메소드 호출방법
  1. 부모클래스로 타입변환하여 메소드 호출
  2. 부모타입의 매개변수에 자식객체 대입하여 메소드 다형성 적용
