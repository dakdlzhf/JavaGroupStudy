## 13.6 와일드카드 타입 ( <?> <? extends...> <? super ...> )



:star2: 와일드카드 를 이용한 Generic 

*  ? 를 코드에서는 일반적으로 와일드 카드라고 부릅니다.

* 제네릭 타입을 매개값이나, 리턴 타입으로 사용할 때 구체적인타입 대신에 와일드 카드를 사용할수 있습니다.

  *  제네릭 타입 < ? > 
    * 모든 클래스나 인터페이스 타입이 올수 있다는 뜻입니다.

  

  :star: `A` 클래스 밑으로 `B` 클래스와  `C` 클래스가 있습니다

  그리고 `C` 클래스 밑에는 하위클래스 `D` 클래스 만 존재한다면,

  이럴때 와일드 카드 타입을 이용하여 어떻게 사용할수 있는지 보겠습니다.

  

  * 제네릭타입 < ? extends 상한선클래스 >  <- C
    * 지정된 클래스 밑으로만 접근이가능합니다.
    * 즉 <? extends C >  지정된 C 클래스 와 D 클래스 만 타입을 갖을수있으며, C 클래스 이상의 타입은 제한 받습니다.
  * 제네릭타입 < ? super 하한선클래스 > <- C
    * 지정된 클래스 밑으로는 제약할수 있습니다.
    * <? super C>    지정된  C 클래스가 하한선이 되었기때문에  C 클래스의 상위클래스인 A 클래스까지 ,  즉 C 클래스의 조상클래스 타입까지는 갖을수있지만 C 클래스 이하의 타입은 제한 을 받습니다.



**<u>이처럼 메소드의 입구와 출구에서 타입 파라미터에 상한선과 하한선 을 두어 객체 접근에 제약을 둘때 와일드카드를 사용하면 됩니다.</u>**



## 13.7 제네릭 타입의 상속과 구현



:star: 우선 Generic 에대해 간략하게 소개하겠습니다

* Generic 이란 클래스 내부에서 지정하는것이아닌 외부 사용자에 의해 지정되는것을 의미합니다.
  * Class 타입과 Interface 타입에 Generic 을 지정하는 방법들을 보겠습니다.





* 제네릭 타입도 다른타입처럼 부모 클래스가 될 수 있습니다.
  * 클래스와 인터페이스를 상속하듯이 extends 와 implements 를 앞에 붙여줍니다.

```
public class ChildProduct<T, M> extends Product<T, M> { ... }
```

* 제네릭 인터페이스를 구현하는 클래스는 부모의 타입 을  선언해야 합니다.
* 그 외에는 일반적인 인터페이스의 구현 클래스와 크게 다르지 않습니다.

```
public class StorageImpl<T> implement Storage<T> { ... }
```

* 이렇게 Class , Interface 사용시 부모의 타입 과 상속받는 자식 클래스는  같은  타입이어야 합니다. 
* 자식 클래스는 추가적인 타입 파라미터를 가질수도 있습니다. 



```
public class 자식제품<K,V,C> extends 제품<K, V> {
        private C 회사;

    public C get회사() {
        return 회사;
    }

    public void set회사(C 회사) {
        this.회사 = 회사;
    }
}
```



 이렇게 클래스나 인터페이스에 타입을 지정해놓고 Getter 와 Setter 를 이용한다면

원치않는 타입이 들어올수없도록 타입을 바로 체크할수 있습니다.
